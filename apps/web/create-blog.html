<!doctype html>
<!--
  SPDX-License-Identifier: AGPL-3.0-or-later
  Copyright (C) 2025 Joshua Vlantis
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Create Blog Post – Wave Finder</title>
  <meta name="description" content="Create and contribute blog posts to Wave Finder." />
  <link rel="canonical" href="https://wavefinder.org/create-blog.html" />
  <meta name="robots" content="noindex,nofollow" />
  
  <link rel="preload" href="/static/fonts/Outfit-400.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/static/fonts/Outfit-600.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="stylesheet" href="/static/fonts/outfit.css">
  <link rel="icon" href="/static/logo32.png" type="image/png" sizes="32x32">
  <link rel="stylesheet" href="/static/wf-header.css?v=2025-10-05-1">
  <link rel="stylesheet" href="/static/wf-glow.css?v=2025-10-08-1">
  
  <!-- Load marked.js for preview -->
  <script src="/static/marked.min.js"></script>
  <!-- Load JSZip for file packaging -->
  <script src="static/jszip.min.js"></script>
  
  <style>
    :root{ --c-bg:#121212; --c-panel:#1e1e1e; --c-border:#2b3440; --c-accent:#4fc3f7; --c-text:#eaeef5; --c-dim:#aab3c2; --r:12px }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:'Outfit',system-ui,Segoe UI,Roboto,Arial; background:var(--c-bg); color:var(--c-text); position:relative }
    
    main{ max-width:1400px; margin:0 auto; padding:120px 20px 40px; position:relative; z-index:1 }
    
    .creator{ background:linear-gradient(180deg, rgba(34,39,46,.9), rgba(22,26,31,.95)); border:1px solid var(--c-border); border-radius:12px; box-shadow:0 12px 28px rgba(0,0,0,.28); overflow:hidden }
    
    .creator-header{ padding:20px; border-bottom:1px solid var(--c-border); background:rgba(255,255,255,.02) }
    .creator-header h1{ margin:0 0 8px; font-size:24px; text-align:center }
    .creator-header p{ margin:0; color:var(--c-dim); text-align:center; font-size:14px }
    
    .creator-body{ display:grid; grid-template-columns:1fr 1fr; min-height:600px }
    @media (max-width: 1200px){ .creator-body{ grid-template-columns:1fr; } }
    
    .editor-panel{ display:flex; flex-direction:column }
    .preview-panel{ border-left:1px solid var(--c-border); display:flex; flex-direction:column }
    @media (max-width: 1200px){ .preview-panel{ border-left:0; border-top:1px solid var(--c-border) } }
    
    .panel-header{ padding:12px 16px; background:rgba(255,255,255,.03); border-bottom:1px solid var(--c-border); display:flex; justify-content:space-between; align-items:center; font-size:14px; font-weight:600 }
    
    .toolbar{ display:flex; flex-wrap:wrap; gap:4px; padding:8px 12px; border-bottom:1px solid var(--c-border); background:rgba(255,255,255,.02) }
    .tool-btn{ background:rgba(255,255,255,.08); border:1px solid var(--c-border); color:var(--c-text); padding:6px 8px; border-radius:6px; font-size:12px; cursor:pointer; transition:all .2s; font-family:inherit; display:flex; align-items:center; gap:4px }
    .tool-btn:hover{ background:rgba(255,255,255,.15); transform:translateY(-1px) }
    .tool-btn:active{ transform:translateY(0) }
    .tool-btn svg{ width:14px; height:14px }
    
    .editor{ flex:1; background:var(--c-bg); border:0; outline:0; padding:16px; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:14px; line-height:1.6; color:var(--c-text); resize:none }
    .editor::placeholder{ color:var(--c-dim); opacity:0.7 }
    
    .preview{ flex:1; padding:16px; background:rgba(255,255,255,.01); overflow-y:auto }
    
    /* Preview styling matches post.html */
    .preview-content{ color:#d9e2ef; font-size:16px; line-height:1.75; max-width:none }
    .preview-content h1{ font-size:28px; margin-top:24px; margin-bottom:8px }
    .preview-content h2{ font-size:22px; margin-top:18px; margin-bottom:6px }
    .preview-content h3{ font-size:18px; margin-top:14px; margin-bottom:4px }
    .preview-content h4{ font-size:16px; margin-top:12px; margin-bottom:4px; font-weight:600 }
    .preview-content h5{ font-size:14px; margin-top:10px; margin-bottom:3px; font-weight:600 }
    .preview-content h6{ font-size:13px; margin-top:8px; margin-bottom:3px; font-weight:600; color:var(--c-dim) }
    .preview-content p{ margin:10px 0 }
    .preview-content a{ color:var(--c-accent); text-decoration:underline }
    .preview-content strong{ font-weight:600 }
    .preview-content em{ font-style:italic }
    .preview-content del{ text-decoration:line-through; opacity:0.7 }
    .preview-content ul, .preview-content ol{ margin:10px 0 10px 20px }
    .preview-content li{ margin:4px 0 }
    .preview-content li > ul, .preview-content li > ol{ margin:4px 0 4px 20px }
    .preview-content code{ background:rgba(255,255,255,0.06); padding:0 4px; border-radius:4px; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:.95em }
    .preview-content pre{ background:rgba(255,255,255,0.04); border:1px solid var(--c-border); border-radius:8px; padding:12px; margin:12px 0; overflow-x:auto }
    .preview-content pre code{ background:none; padding:0; border-radius:0; font-size:14px }
    .preview-content table{ border-collapse:collapse; width:100%; margin:12px 0; border-radius:8px; overflow:hidden; border:1px solid var(--c-border) }
    .preview-content th, .preview-content td{ padding:8px 12px; text-align:left; border-bottom:1px solid var(--c-border) }
    .preview-content th{ background:rgba(255,255,255,0.04); font-weight:600 }
    .preview-content tr:last-child td{ border-bottom:0 }
    .preview-content tr:nth-child(even){ background:rgba(255,255,255,0.02) }
    .preview-content blockquote{ border-left:3px solid var(--c-accent); margin:12px 0; padding:8px 12px; color:#c9d6e8; background:rgba(79,195,247,.06); border-radius:6px }
    .preview-content img{ max-width:100%; border-radius:8px; display:block; margin:10px auto }
    .preview-content hr{ border:0; border-top:1px solid var(--c-border); margin:16px 0 }
    
    .metadata-panel{ padding:20px; border-top:1px solid var(--c-border) }
    .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px }
    @media (max-width: 800px){ .form-grid{ grid-template-columns:1fr } }
    
    .form-group{ display:flex; flex-direction:column; gap:6px }
    .form-group.full{ grid-column:1/-1 }
    
    .form-label{ font-size:14px; font-weight:600; color:var(--c-text) }
    .form-input, .form-textarea{ background:rgba(255,255,255,.06); border:1px solid var(--c-border); color:var(--c-text); padding:8px 12px; border-radius:8px; font-family:inherit; font-size:14px }
    .form-input:focus, .form-textarea:focus{ outline:2px solid var(--c-accent); outline-offset:-1px }
    .form-input::placeholder, .form-textarea::placeholder{ color:var(--c-dim); opacity:0.7 }
    .form-textarea{ resize:vertical; min-height:60px; font-family:inherit }
    
    .tag-input-wrapper{ position:relative }
    .tag-chips{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px }
    .tag-chip{ background:var(--c-accent); color:var(--c-bg); padding:4px 8px; border-radius:999px; font-size:12px; display:flex; align-items:center; gap:4px }
    .tag-remove{ cursor:pointer; font-weight:700; opacity:0.7 }
    .tag-remove:hover{ opacity:1 }
    
    .actions{ display:flex; gap:12px; justify-content:center; padding:20px; border-top:1px solid var(--c-border) }
    .btn{ background:var(--c-accent); color:var(--c-bg); border:0; padding:12px 24px; border-radius:8px; font-weight:600; font-family:inherit; cursor:pointer; transition:all .2s; display:flex; align-items:center; gap:8px }
    .btn:hover{ background:#5dd4ff; transform:translateY(-1px) }
    .btn:active{ transform:translateY(0) }
    .btn-secondary{ background:transparent; color:var(--c-text); border:1px solid var(--c-border) }
    .btn-secondary:hover{ background:rgba(255,255,255,.08) }
    
    .stats{ font-size:12px; color:var(--c-dim); margin-left:auto }
    
    .help-text{ font-size:12px; color:var(--c-dim); margin-top:4px }
    
    /* Image Dialog */

    .dialog-content{ background:var(--c-panel); border:1px solid var(--c-border); border-radius:12px; padding:24px; max-width:500px; width:90%; max-height:80vh; overflow-y:auto }
    .dialog-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:20px }
    .dialog-title{ font-size:18px; font-weight:600; margin:0 }
    .dialog-close{ background:none; border:none; color:var(--c-text); font-size:24px; cursor:pointer; padding:0; line-height:1 }
    
    .image-options{ display:grid; gap:16px; margin-bottom:20px }
    .image-option{ padding:16px; border:1px solid var(--c-border); border-radius:8px; cursor:pointer; transition:all .2s; text-align:center }
    .image-option:hover{ background:rgba(255,255,255,.04); border-color:var(--c-accent) }
    .image-option.active{ background:rgba(79,195,247,.1); border-color:var(--c-accent) }
    
    .file-input{ display:none }
    .upload-area{ border:2px dashed var(--c-border); border-radius:8px; padding:32px; text-align:center; margin:12px 0; transition:all .2s }
    .upload-area:hover, .upload-area.dragover{ border-color:var(--c-accent); background:rgba(79,195,247,.05) }
    
    .image-preview{ max-width:100%; max-height:200px; border-radius:8px; margin:12px 0; display:none }
    .image-info{ font-size:12px; color:var(--c-dim); margin:8px 0 }
    
    .dialog-actions{ display:flex; gap:12px; justify-content:flex-end; margin-top:20px }
    .load-section {
      margin-top: 20px;
      padding: 16px;
      background: rgba(79, 195, 247, 0.1);
      border: 1px solid rgba(79, 195, 247, 0.3);
      border-radius: 8px;
    }
    
    .load-section h3 {
      margin: 0 0 8px;
      font-size: 16px;
      color: var(--c-accent);
    }
    
    .load-section p {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--c-dim);
    }
    
    .upload-area {
      border: 2px dashed var(--c-border);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      background: rgba(255, 255, 255, 0.02);
    }
    
    .upload-area:hover {
      border-color: var(--c-accent);
      background: rgba(79, 195, 247, 0.05);
    }
    
    .upload-area.dragover {
      border-color: var(--c-accent);
      background: rgba(79, 195, 247, 0.1);
    }
    
    .upload-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      color: var(--c-dim);
    }
    
    .upload-content svg {
      opacity: 0.6;
    }
    
    .upload-content span {
      font-size: 14px;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="wf-header"></div>

  <main>
    <div class="creator">
      <div class="creator-header">
        <h1>Create Blog Post</h1>
        <p>Write your blog post in markdown and generate files to contribute to Wave Finder</p>
        
        <div class="load-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 style="margin: 0;">📂 Load Existing Project</h3>
            <button type="button" onclick="clearAll()" style="padding: 4px 8px; font-size: 12px; background: rgba(255,255,255,0.1); border: 1px solid var(--c-border); border-radius: 4px; color: var(--c-dim); cursor: pointer;">🗑️ Clear All</button>
          </div>
          <p>Upload a previously generated zip file to continue editing</p>
          <div class="upload-area" id="zipUploadArea">
            <input type="file" id="zipFileInput" accept=".zip" style="display: none;">
            <div class="upload-content">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
              </svg>
              <span>Click to upload ZIP file or drag & drop</span>
            </div>
          </div>
        </div>
      </div>
      
      <div class="creator-body">
        <!-- Editor Panel -->
        <div class="editor-panel">
          <div class="panel-header">
            <span>📝 Editor</span>
            <div class="stats" id="stats">0 words • 0 chars</div>
          </div>
          
          <div class="toolbar">
            <button class="tool-btn" onclick="insertText('# ', 'block')" title="Heading">
              <strong>H</strong>
            </button>
            <button class="tool-btn" onclick="wrapText('**')" title="Bold">
              <strong>B</strong>
            </button>
            <button class="tool-btn" onclick="wrapText('*')" title="Italic">
              <em>I</em>
            </button>
            <button class="tool-btn" onclick="insertText('- ', 'block')" title="Bullet List">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M2 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm3.75-1.5a.75.75 0 0 0 0 1.5h8.5a.75.75 0 0 0 0-1.5h-8.5zm0 5a.75.75 0 0 0 0 1.5h8.5a.75.75 0 0 0 0-1.5h-8.5zm0 5a.75.75 0 0 0 0 1.5h8.5a.75.75 0 0 0 0-1.5h-8.5zM2 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>
            </button>
            <button class="tool-btn" onclick="insertText('1. ', 'block')" title="Numbered List">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M2.003 2.5a.5.5 0 0 0-.723-.447l-1.003.5a.5.5 0 0 0 .446.894l.28-.14V6H.5a.5.5 0 0 0 0 1h2.006a.5.5 0 1 0 0-1h-.503V2.5zM5 3.25a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5A.75.75 0 0 1 5 3.25zm0 5a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5A.75.75 0 0 1 5 8.25zm0 5a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1-.75-.75zM.924 10.32l.003-.004a.851.851 0 0 1 .144-.329c.08-.12.18-.253.32-.422.28-.338.655-.822 1.097-1.432C2.987 7.58 3.5 6.75 3.5 6a2.5 2.5 0 0 0-5 0 .5.5 0 1 0 1 0 1.5 1.5 0 0 1 3 0c0 .555-.301 1.185-.796 1.72-.247.267-.497.573-.747.88-.125.153-.249.308-.372.462-.061.077-.120.155-.18.230a2.34 2.34 0 0 0-.123.172.827.827 0 0 0-.029.05l-.004.008v.001l.001.001a.5.5 0 0 0 .039.64.75.75 0 0 0 .569.25h2.5a.5.5 0 0 0 0-1H.924z"/></svg>
            </button>
            <button class="tool-btn" onclick="insertText('> ', 'block')" title="Blockquote">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M2.5 3a.5.5 0 0 0 0 1h11a.5.5 0 0 0 0-1h-11zm5 3a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1h-6zm0 3a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1h-6zm-5-3a.5.5 0 0 0-.5-.5.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5.5.5 0 0 0 .5-.5V6z"/></svg>
            </button>
            <button class="tool-btn" onclick="wrapText('`')" title="Code">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M5.854 4.854a.5.5 0 1 0-.708-.708l-3.5 3.5a.5.5 0 0 0 0 .708l3.5 3.5a.5.5 0 0 0 .708-.708L2.707 8l3.147-3.146zm4.292 0a.5.5 0 0 1 .708-.708l3.5 3.5a.5.5 0 0 1 0 .708l-3.5 3.5a.5.5 0 0 1-.708-.708L13.293 8l-3.147-3.146z"/></svg>
            </button>
            <button class="tool-btn" onclick="insertLink()" title="Link">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M6.354 5.5H4a3 3 0 0 0 0 6h3a3 3 0 0 0 2.83-4H9c-.086 0-.17.01-.25.031A2 2 0 0 1 7 9.5H4a2 2 0 1 1 0-4h1.535c.218-.376.495-.714.82-1z"/><path d="M9 5.5a3 3 0 0 0-2.83 4h1.098A2 2 0 0 1 9 6.5h3a2 2 0 1 1 0 4h-1.535a4.02 4.02 0 0 1-.82 1H12a3 3 0 1 0 0-6H9z"/></svg>
            </button>
            <button class="tool-btn" onclick="triggerImageUpload()" title="Add Image">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>
            </button>
            <button class="tool-btn" onclick="insertTable()" title="Table">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z"/></svg>
            </button>
            <button class="tool-btn" onclick="openBlogPreview()" title="Preview Blog" style="color: #4fc3f7; min-width: 60px;">
              Preview
            </button>

            <button class="tool-btn" onclick="insertText('---\n\n', 'block')" title="Horizontal Rule">
              <svg viewBox="0 0 16 16" fill="currentColor"><path d="M12 8a1 1 0 0 1 1 1v2.5h2.5a.5.5 0 0 1 0 1H13V15a1 1 0 0 1-2 0v-2.5H8.5a.5.5 0 0 1 0-1H11V9a1 1 0 0 1 1-1zm-6-8a1 1 0 0 1 1 1v6.5a.5.5 0 0 1-1 0V1a1 1 0 0 1 1-1zM1 8a1 1 0 0 1 1-1h2.5a.5.5 0 0 1 0 1H2v6.5a.5.5 0 0 1-1 0V8z"/></svg>
            </button>
          </div>
          
          <textarea id="editor" class="editor" placeholder="# Your Blog Post Title

Write your blog post content here using markdown...

## Example Section

You can use all standard markdown features:

- **Bold text**
- *Italic text*  
- `inline code`
- [Links](https://example.com)
- Images: ![Alt text](image-url.jpg)

> Blockquotes for important notes

```javascript
// Code blocks with syntax highlighting
console.log('Hello Wave Finder!');
```

### Tables

| Feature | Supported |
|---------|-----------|
| Headers | ✅ |
| Lists | ✅ |
| Code | ✅ |

---

*Happy writing!*"></textarea>
        </div>
        
        <!-- Preview Panel -->
        <div class="preview-panel">
          <div class="panel-header">
            <span>👀 Preview</span>
          </div>
          <div class="preview">
            <div id="preview-content" class="preview-content">
              <p><em>Your markdown preview will appear here...</em></p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Metadata Panel -->
      <div class="metadata-panel">
        <h3 style="margin:0 0 16px; font-size:18px">📋 Post Metadata</h3>
        <div class="form-grid">
          <div class="form-group">
            <label class="form-label" for="title">Title *</label>
            <input type="text" id="title" class="form-input" placeholder="Your Blog Post Title" required>
            <div class="help-text">This will be the main title displayed on your blog post</div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="author">Author *</label>
            <input type="text" id="author" class="form-input" placeholder="Your Name" required>
            <div class="help-text">Your name as you want it to appear</div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="slug">Slug *</label>
            <input type="text" id="slug" class="form-input" placeholder="my-blog-post" required>
            <div class="help-text">URL-friendly version (lowercase, hyphens only)</div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="date">Date</label>
            <input type="date" id="date" class="form-input">
            <div class="help-text">Publication date (defaults to today)</div>
          </div>
          
          <div class="form-group full">
            <label class="form-label" for="excerpt">Excerpt *</label>
            <textarea id="excerpt" class="form-textarea" placeholder="A brief summary of your blog post (1-2 sentences)" required></textarea>
            <div class="help-text">This appears in the blog listing and search results</div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="tags">Tags</label>
            <div class="tag-input-wrapper">
              <input type="text" id="tags" class="form-input" placeholder="Press Enter to add tags">
              <div class="help-text">Type a tag and press Enter. Examples: diving, spearfishing, spots</div>
            </div>
            <div id="tag-chips" class="tag-chips"></div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="cover">Cover Image</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <input type="text" id="cover" class="form-input" placeholder="/Images/my-image.jpg" style="flex:1;">
              <button type="button" class="btn btn-secondary" onclick="showCoverImageDialog()" style="padding:8px 12px; white-space:nowrap;">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>
                Upload
              </button>
            </div>
            <div class="help-text">Optional: Path to cover image or upload your own</div>
            <div id="cover-preview-container" style="margin-top:8px; display:none;">
              <img id="cover-preview" style="max-width:100%; max-height:150px; border-radius:8px; border:1px solid var(--c-border);" alt="Cover preview">
              <div id="cover-info" style="font-size:12px; color:var(--c-dim); margin-top:4px;"></div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Actions -->
      <div class="actions">
        <button class="btn btn-secondary" onclick="resetForm()">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg>
          Reset
        </button>
        <button class="btn" onclick="generateZipFile()">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M6.5 7.5a1 1 0 0 1 1-1h1a1 1 0 0 1 1 1v.938l.4 1.599a1 1 0 0 1-.416 1.074l-.93.62a1 1 0 0 1-1.109 0l-.93-.62a1 1 0 0 1-.415-1.074L7.5 8.438V7.5z"/><path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2zm5.5-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H8.5v1h-1V1z"/></svg>
          Generate Blog Package
        </button>
      </div>
    </div>
  </main>

  <!-- Hidden file input for cover image -->
  <input type="file" id="cover-file-input" style="display:none;" accept="image/*" onchange="handleCoverImageUpload(event)">

  <!-- Hidden file input for images -->
  <input type="file" id="image-file-input" accept="image/*" style="display: none;">

  <script src="/static/wf-header.js?v=2025-10-07-1" defer></script>
  <script>
    // Configure marked.js
    marked.setOptions({
      gfm: true,
      breaks: false,
      pedantic: false,
      sanitize: false,
      smartypants: false
    });

    // Custom renderer for external links and lazy images
    const renderer = new marked.Renderer();
    const originalLink = renderer.link;
    renderer.link = function(href, title, text) {
      const isExternal = href && !href.startsWith('/') && !href.startsWith('#') && !href.includes(window.location.hostname);
      const link = originalLink.call(this, href, title, text);
      if (isExternal) {
        return link.replace('<a ', '<a target="_blank" rel="noopener" ');
      }
      return link;
    };

    const originalImage = renderer.image;
    renderer.image = function(href, title, text) {
      const img = originalImage.call(this, href, title, text);
      return img.replace('<img ', '<img loading="lazy" ');
    };

    // State
    const editor = document.getElementById('editor');
    const previewContent = document.getElementById('preview-content');
    const stats = document.getElementById('stats');
    const tagChips = document.getElementById('tag-chips');
    const tagInput = document.getElementById('tags');
    
    let tags = [];

    // Auto-generate slug from title
    document.getElementById('title').addEventListener('input', (e) => {
      const slug = e.target.value
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
      document.getElementById('slug').value = slug;
    });

    // Set default date to today
    document.getElementById('date').value = new Date().toISOString().split('T')[0];

    // Editor functions
    function getSelectionInfo() {
      return {
        start: editor.selectionStart,
        end: editor.selectionEnd,
        text: editor.value.substring(editor.selectionStart, editor.selectionEnd)
      };
    }

    function insertAtCursor(text) {
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      const before = editor.value.substring(0, start);
      const after = editor.value.substring(end);
      
      editor.value = before + text + after;
      editor.focus();
      editor.selectionStart = editor.selectionEnd = start + text.length;
      updatePreview();
    }

    function insertText(text, type = 'inline') {
      const selection = getSelectionInfo();
      
      if (type === 'block') {
        // Insert at beginning of current line
        const beforeCursor = editor.value.substring(0, selection.start);
        const lineStart = beforeCursor.lastIndexOf('\n') + 1;
        const line = editor.value.substring(lineStart, selection.start);
        
        // If line is empty or only whitespace, insert at current position
        if (line.trim() === '') {
          insertAtCursor(text);
        } else {
          // Insert at beginning of line
          editor.selectionStart = editor.selectionEnd = lineStart;
          insertAtCursor(text);
        }
      } else {
        insertAtCursor(text);
      }
    }

    function wrapText(wrapper) {
      const selection = getSelectionInfo();
      
      if (selection.text) {
        const wrappedText = wrapper + selection.text + wrapper;
        insertAtCursor(wrappedText);
        // Select the wrapped content
        editor.selectionStart = selection.start + wrapper.length;
        editor.selectionEnd = selection.start + wrapper.length + selection.text.length;
      } else {
        insertAtCursor(wrapper + wrapper);
        // Position cursor between wrappers
        editor.selectionStart = editor.selectionEnd = selection.start + wrapper.length;
      }
    }

    function insertLink() {
      const selection = getSelectionInfo();
      const text = selection.text || 'link text';
      const linkMd = `[${text}](https://example.com)`;
      insertAtCursor(linkMd);
    }

    // Image handling
    let selectedImageType = 'upload';
    let currentImageFile = null;
    
    function triggerImageUpload() {
      const fileInput = document.getElementById('image-file-input');
      fileInput.click();
    }
    
    // Handle direct image upload
    document.getElementById('image-file-input').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file type
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file');
        return;
      }
      
      // Validate file size (5MB limit)
      const maxSize = 5 * 1024 * 1024;
      if (file.size > maxSize) {
        alert('Image file is too large. Please choose a file under 5MB.');
        return;
      }
      
      // Process the image immediately
      const reader = new FileReader();
      reader.onload = function(e) {
        const dataUrl = e.target.result;
        
        // Generate alt text from filename
        const altText = file.name.replace(/\.[^/.]+$/, '').replace(/[-_]/g, ' ');
        const fileName = file.name;
        const placeholder = `/Images/${fileName}`;
        
        // Store the mapping for preview rendering
        if (!window.imageMap) window.imageMap = new Map();
        window.imageMap.set(placeholder, dataUrl);
        
        // Use placeholder in markdown for clean editing
        const imageMd = `![${altText}](${placeholder})`;
        insertAtCursor(imageMd);
        
        // Add a comment with file details
        const comment = `\n<!-- 📎 ATTACHED FILE: "${fileName}" (${Math.round(file.size/1024)}KB) - Remember to send this file! -->\n`;
        insertAtCursor(comment);
        
        // Store the file reference for later
        if (!window.attachedImages) window.attachedImages = [];
        const imgObj = {
          file: file,
          placeholder: placeholder,
          altText: altText
        };
        window.attachedImages.push(imgObj);
        
        // Cache the image for persistence
        cacheImage(imgObj);
        
        updatePreview(); // Refresh preview immediately
        
        // Show brief confirmation
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: rgba(76, 175, 80, 0.9);
          color: white;
          padding: 8px 12px;
          border-radius: 6px;
          z-index: 10001;
          font-size: 13px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        notification.innerHTML = `✅ Image "${fileName}" added`;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.transition = 'opacity 0.3s ease';
          notification.style.opacity = '0';
          setTimeout(() => notification.remove(), 300);
        }, 2000);
      };
      reader.readAsDataURL(file);
      
      // Reset file input to allow selecting the same file again
      this.value = '';
    });
    
    // Cover image handling
    let coverImageFile = null;
    
    function showCoverImageDialog() {
      document.getElementById('cover-file-input').click();
    }
    
    function handleCoverImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file type
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file');
        return;
      }
      
      // Validate file size (5MB limit)
      const maxSize = 5 * 1024 * 1024;
      if (file.size > maxSize) {
        alert('Image file is too large. Please choose a file under 5MB.');
        return;
      }
      
      coverImageFile = file;
      
      // Show preview
      const reader = new FileReader();
      reader.onload = function(e) {
        // Update cover input with placeholder path
        const placeholder = `/Images/${file.name}`;
        document.getElementById('cover').value = placeholder;
        
        // Show preview
        const preview = document.getElementById('cover-preview');
        const container = document.getElementById('cover-preview-container');
        const info = document.getElementById('cover-info');
        
        preview.src = e.target.result;
        container.style.display = 'block';
        
        // Show file info
        const sizeKB = Math.round(file.size / 1024);
        info.textContent = `File: ${file.name} (${sizeKB} KB) - Remember to send this file!`;
        
        // Store in image map for preview
        if (!window.imageMap) window.imageMap = new Map();
        window.imageMap.set(placeholder, e.target.result);
        
        // Store for file generation
        if (!window.attachedImages) window.attachedImages = [];
        // Remove any previous cover image entry
        window.attachedImages = window.attachedImages.filter(img => !img.isCover);
        const coverImgObj = {
          file: coverImageFile,
          placeholder: placeholder,
          altText: 'Cover image',
          isCover: true
        };
        window.attachedImages.push(coverImgObj);
        
        // Cache the cover image for persistence
        cacheImage(coverImgObj);
      };
      reader.readAsDataURL(file);
    }
    
    // Update cover preview when URL is manually entered
    function updateCoverPreview() {
      const coverUrl = document.getElementById('cover').value.trim();
      const container = document.getElementById('cover-preview-container');
      const preview = document.getElementById('cover-preview');
      const info = document.getElementById('cover-info');
      
      if (coverUrl) {
        // Check if it's a placeholder for uploaded image
        if (window.imageMap && window.imageMap.has(coverUrl)) {
          preview.src = window.imageMap.get(coverUrl);
          container.style.display = 'block';
          info.textContent = 'Uploaded image preview';
        } else if (coverUrl.startsWith('/Images/') || coverUrl.startsWith('http')) {
          // Try to show external/existing image
          preview.src = coverUrl;
          container.style.display = 'block';
          info.textContent = 'External/existing image';
          preview.onerror = () => {
            container.style.display = 'none';
          };
        } else {
          container.style.display = 'none';
        }
      } else {
        container.style.display = 'none';
      }
    }

    // Simple blog preview function using post.html styling
    function openBlogPreview() {
      const title = document.getElementById('title').value.trim() || 'Untitled Blog Post';
      const author = document.getElementById('author').value.trim() || 'Anonymous';
      const date = document.getElementById('date').value || new Date().toISOString().split('T')[0];
      const cover = document.getElementById('cover').value.trim();
      let content = editor.value.trim() || '# Welcome\n\nYour blog content will appear here...';
      
      // Replace image placeholders with actual images for preview
      if (window.imageMap) {
        window.imageMap.forEach((imageUrl, placeholder) => {
          const escapedPlaceholder = placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          content = content.replace(
            new RegExp('\\!\\[([^\\]]*)\\]\\(' + escapedPlaceholder + '\\)', 'g'),
            '![$1](' + imageUrl + ')'
          );
        });
      }
      
      const previewWindow = window.open('', 'blog-preview', 'width=1000,height=800,scrollbars=yes,resizable=yes');
      
      if (previewWindow) {
        const formattedDate = new Date(date).toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        // Create a simple preview that loads post.html styles
        previewWindow.document.open();
        previewWindow.document.write('<!doctype html><html><head><title>Preview: ' + title + '</title>');
        previewWindow.document.write('<link rel="stylesheet" href="/static/fonts/outfit.css">');
        previewWindow.document.write('<link rel="stylesheet" href="/static/wf-glow.css">');
        previewWindow.document.write('<style>');
        previewWindow.document.write(':root{--c-bg:#121212;--c-panel:#1e1e1e;--c-border:#2b3440;--c-accent:#4fc3f7;--c-text:#eaeef5;--c-dim:#aab3c2}');
        previewWindow.document.write('*{box-sizing:border-box}');
        previewWindow.document.write('body{margin:0;font-family:OutfitLocal,Arial;background:var(--c-bg);color:var(--c-text);padding:20px}');
        previewWindow.document.write('.preview-banner{background:#ff6b35;color:white;text-align:center;padding:8px;margin:-20px -20px 20px;font-size:14px}');
        previewWindow.document.write('.post{background:linear-gradient(180deg,rgba(34,39,46,.9),rgba(22,26,31,.95));border:1px solid var(--c-border);border-radius:12px;padding:20px;max-width:800px;margin:0 auto}');
        previewWindow.document.write('.cover{width:100%;aspect-ratio:16/9;object-fit:cover;border-radius:10px;margin:0 0 12px}');
        previewWindow.document.write('h1.title{margin:0 0 6px;font-size:26px;text-align:center}');
        previewWindow.document.write('.meta{color:var(--c-dim);font-size:12px;margin-bottom:10px;text-align:center}');
        previewWindow.document.write('.tags{display:flex;flex-wrap:wrap;gap:6px;justify-content:center;margin-bottom:14px}');
        previewWindow.document.write('.tag{padding:4px 8px;border:1px solid #3a4755;border-radius:999px;font-size:12px;color:#cfe3f6;background:rgba(255,255,255,.04)}');
        previewWindow.document.write('.content{color:#d9e2ef;font-size:16px;line-height:1.75}');
        previewWindow.document.write('.content h1{font-size:28px;margin-top:24px;margin-bottom:8px}');
        previewWindow.document.write('.content h2{font-size:22px;margin-top:18px;margin-bottom:6px}');
        previewWindow.document.write('.content h3{font-size:18px;margin-top:14px;margin-bottom:4px}');
        previewWindow.document.write('.content p{margin:10px 0}');
        previewWindow.document.write('.content a{color:var(--c-accent);text-decoration:underline}');
        previewWindow.document.write('.content strong{font-weight:600}');
        previewWindow.document.write('.content em{font-style:italic}');
        previewWindow.document.write('.content ul,.content ol{margin:10px 0 10px 20px}');
        previewWindow.document.write('.content li{margin:4px 0}');
        previewWindow.document.write('.content code{background:rgba(255,255,255,0.06);padding:0 4px;border-radius:4px;font-size:.95em}');
        previewWindow.document.write('.content pre{background:rgba(255,255,255,0.04);border:1px solid var(--c-border);border-radius:8px;padding:12px;margin:12px 0;overflow-x:auto}');
        previewWindow.document.write('.content blockquote{border-left:3px solid var(--c-accent);margin:12px 0;padding:8px 12px;color:#c9d6e8;background:rgba(79,195,247,.06);border-radius:6px}');
        previewWindow.document.write('.content img{max-width:100%;border-radius:8px;display:block;margin:10px auto}');
        previewWindow.document.write('.content hr{border:0;border-top:1px solid var(--c-border);margin:16px 0}');
        previewWindow.document.write('</style></head><body>');
        previewWindow.document.write('<div class="preview-banner">🔍 PREVIEW MODE - Wave Finder Blog Post</div>');
        previewWindow.document.write('<article class="post">');
        if (cover) {
          const coverSrc = window.imageMap && window.imageMap.has(cover) ? window.imageMap.get(cover) : cover;
          previewWindow.document.write('<img class="cover" src="' + coverSrc + '" alt="Cover Image">');
        }
        previewWindow.document.write('<h1 class="title">' + title + '</h1>');
        previewWindow.document.write('<div class="meta">' + formattedDate + ' • ' + author + '</div>');
        if (tags.length > 0) {
          previewWindow.document.write('<div class="tags">');
          tags.forEach(tag => {
            previewWindow.document.write('<span class="tag">' + tag + '</span>');
          });
          previewWindow.document.write('</div>');
        }
        previewWindow.document.write('<div class="content" id="content"></div>');
        previewWindow.document.write('</article>');
        previewWindow.document.write('<sc' + 'ript src="/static/marked.min.js"></sc' + 'ript>');
        previewWindow.document.write('<sc' + 'ript>');
        previewWindow.document.write('marked.setOptions({gfm:true,breaks:false});');
        previewWindow.document.write('const content=' + JSON.stringify(content) + ';');
        previewWindow.document.write('try{');
        previewWindow.document.write('document.getElementById("content").innerHTML=marked.parse(content);');
        previewWindow.document.write('}catch(e){');
        previewWindow.document.write('document.getElementById("content").innerHTML="<p>Error rendering content</p>";');
        previewWindow.document.write('}');
        previewWindow.document.write('</sc' + 'ript></body></html>');
        previewWindow.document.close();
        previewWindow.focus();
      } else {
        alert('Please allow popups to view the blog preview');
      }
    }



    function insertTable() {
      const tableMd = `| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |\n\n`;
      insertAtCursor(tableMd);
    }

    // Preview update
    function updatePreview() {
      let markdown = editor.value;
      
      // Replace image placeholders with data URLs for preview
      if (window.imageMap) {
        window.imageMap.forEach((dataUrl, placeholder) => {
          // Replace placeholder paths with data URLs for preview
          const escapedPlaceholder = placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          markdown = markdown.replace(
            new RegExp(`\\!\\[([^\\]]*)\\]\\(${escapedPlaceholder}\\)`, 'g'),
            `![$1](${dataUrl})`
          );
        });
      }
      
      try {
        const html = marked.parse(markdown, { renderer });
        previewContent.innerHTML = html || '<p><em>Start writing to see the preview...</em></p>';
        
        // Add visual indicators for broken images
        const brokenImages = previewContent.querySelectorAll('img');
        brokenImages.forEach(img => {
          if (img.src.startsWith('/Images/') || img.src.includes('Images/')) {
            // This is likely a placeholder that didn't get replaced
            img.onerror = function() {
              const placeholder = document.createElement('div');
              placeholder.style.cssText = `
                display: inline-block;
                padding: 12px;
                background: linear-gradient(45deg, rgba(255,193,7,0.1), rgba(255,152,0,0.1));
                border: 2px dashed rgba(255,193,7,0.5);
                border-radius: 8px;
                color: #ff9800;
                font-family: inherit;
                font-size: 14px;
                text-align: center;
                min-width: 200px;
                min-height: 60px;
                line-height: 1.4;
                margin: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              
              // Add hover effect
              placeholder.addEventListener('mouseenter', function() {
                this.style.background = 'linear-gradient(45deg, rgba(255,193,7,0.2), rgba(255,152,0,0.2))';
                this.style.borderColor = 'rgba(255,193,7,0.8)';
                this.style.transform = 'scale(1.02)';
              });
              
              placeholder.addEventListener('mouseleave', function() {
                this.style.background = 'linear-gradient(45deg, rgba(255,193,7,0.1), rgba(255,152,0,0.1))';
                this.style.borderColor = 'rgba(255,193,7,0.5)';
                this.style.transform = 'scale(1)';
              });
              placeholder.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px; min-height: 60px;">
                  <span style="font-size: 18px;">🖼️</span>
                  <div>
                    <div style="font-weight: 600;">${this.alt || 'Image'}</div>
                    <div style="font-size: 12px; opacity: 0.7;">Preview unavailable - click to restore</div>
                  </div>
                </div>
              `;
              
              // Add click handler to restore images
              placeholder.style.cursor = 'pointer';
              placeholder.addEventListener('click', () => {
                restoreImagesOnly();
              });
              this.parentNode.replaceChild(placeholder, this);
            };
          }
        });
      } catch (error) {
        previewContent.innerHTML = '<p><em>Error parsing markdown</em></p>';
      }
      updateStats();
    }

    function updateStats() {
      const text = editor.value;
      const chars = text.length;
      const words = text.trim() ? text.trim().split(/\s+/).length : 0;
      stats.textContent = `${words} words • ${chars} chars`;
    }

    // Tag management
    function addTag(tag) {
      tag = tag.trim().toLowerCase();
      if (tag && !tags.includes(tag)) {
        tags.push(tag);
        renderTags();
      }
    }

    function removeTag(tag) {
      tags = tags.filter(t => t !== tag);
      renderTags();
    }

    function renderTags() {
      tagChips.innerHTML = tags.map(tag => 
        `<span class="tag-chip">${tag}<span class="tag-remove" onclick="removeTag('${tag}')">×</span></span>`
      ).join('');
    }

    // Tag input handling
    tagInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addTag(e.target.value);
        e.target.value = '';
      }
    });

    // Utility functions
    function updateImageCounter() {
      const count = window.attachedImages ? window.attachedImages.length : 0;
      // If there's an image counter element, update it
      const counter = document.querySelector('.image-counter');
      if (counter) {
        counter.textContent = count > 0 ? `${count} image(s) attached` : 'No images';
      }
    }

    function updateTagsDisplay() {
      const container = document.getElementById('tags-container');
      if (!container) return;
      
      container.innerHTML = '';
      tags.forEach(tag => {
        const tagEl = document.createElement('span');
        tagEl.className = 'tag';
        tagEl.innerHTML = `${tag} <button type="button" onclick="removeTag('${tag}')">×</button>`;
        container.appendChild(tagEl);
      });
    }

    function clearAll() {
      if (confirm('Are you sure you want to clear all content and start fresh?')) {
        // Clear all form fields
        document.getElementById('title').value = '';
        document.getElementById('author').value = '';
        document.getElementById('slug').value = '';
        document.getElementById('excerpt').value = '';
        document.getElementById('date').value = new Date().toISOString().split('T')[0]; // Keep today's date
        document.getElementById('cover').value = '';
        
        // Hide cover image preview
        const coverContainer = document.getElementById('cover-preview-container');
        if (coverContainer) {
          coverContainer.style.display = 'none';
        }
        
        // Clear editor
        editor.value = '';
        
        // Clear tags
        tags.length = 0;
        updateTagsDisplay();
        
        // Clear images
        if (window.attachedImages) {
          // Clean up object URLs to prevent memory leaks
          window.attachedImages.forEach(img => {
            if (img.url) {
              URL.revokeObjectURL(img.url);
            }
          });
          window.attachedImages.length = 0;
        }
        
        // Clear image map
        if (window.imageMap) {
          // Clean up all object URLs
          window.imageMap.forEach(url => URL.revokeObjectURL(url));
          window.imageMap.clear();
        }
        
        // Clear image cache
        clearImageCache();
        
        updateImageCounter();
        
        // Update preview
        updatePreview();
        
        // Reset file input
        document.getElementById('zipFileInput').value = '';
      }
    }

    // ZIP file loading
    function setupZipUpload() {
      const uploadArea = document.getElementById('zipUploadArea');
      const fileInput = document.getElementById('zipFileInput');
      
      // Click to upload
      uploadArea.addEventListener('click', () => {
        fileInput.click();
      });
      
      // File selection
      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          loadZipFile(e.target.files[0]);
        }
      });
      
      // Drag and drop
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].name.endsWith('.zip')) {
          loadZipFile(files[0]);
        } else {
          alert('Please upload a ZIP file.');
        }
      });
    }

    async function loadZipFile(file) {
      try {
        // Show loading state
        const uploadContent = document.querySelector('.upload-content');
        const originalHTML = uploadContent.innerHTML;
        uploadContent.innerHTML = '<svg width="24" height="24" viewBox="0 0 16 16" fill="currentColor" style="animation: spin 1s linear infinite;"><path d="M8 3a5 5 0 1 0 0 10 5 5 0 0 0 0-10zM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8z"/><path d="M8 4.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V5a.5.5 0 0 1 .5-.5z"/></svg><span>Loading project...</span>';

        // Load and extract ZIP
        const zip = new JSZip();
        const zipContents = await zip.loadAsync(file);
        
        let markdownFile = null;
        let metadataFile = null;
        const imageFiles = [];
        
        // Process each file in the ZIP
        for (const [filename, zipEntry] of Object.entries(zipContents.files)) {
          if (zipEntry.dir) continue; // Skip directories
          
          if (filename.endsWith('.md')) {
            markdownFile = zipEntry;
          } else if (filename.endsWith('-metadata.json')) {
            metadataFile = zipEntry;
          } else if (filename.startsWith('Images/') && !filename.endsWith('/')) {
            imageFiles.push(zipEntry);
          }
        }
        
        if (!markdownFile) {
          throw new Error('No markdown (.md) file found in ZIP');
        }
        
        // Load markdown content
        const markdownContent = await markdownFile.async('text');
        editor.value = markdownContent;
        
        // Load metadata if available
        let coverImagePath = null;
        if (metadataFile) {
          const metadataContent = await metadataFile.async('text');
          const metadata = JSON.parse(metadataContent);
          
          // Populate form fields
          document.getElementById('title').value = metadata.title || '';
          document.getElementById('author').value = metadata.author || '';
          document.getElementById('slug').value = metadata.slug || '';
          document.getElementById('excerpt').value = metadata.excerpt || '';
          document.getElementById('date').value = metadata.date || '';
          document.getElementById('cover').value = metadata.cover || '';
          
          // Store cover image path for later processing
          coverImagePath = metadata.cover;
          
          // Load tags
          if (metadata.tags && Array.isArray(metadata.tags)) {
            tags.length = 0; // Clear existing tags
            tags.push(...metadata.tags);
            updateTagsDisplay();
          }
        }
        
        // Load images
        window.attachedImages = window.attachedImages || [];
        window.attachedImages.length = 0; // Clear existing images
        window.imageMap = window.imageMap || new Map(); // Clear existing image map
        
        for (const imageEntry of imageFiles) {
          const imageBlob = await imageEntry.async('blob');
          const imageName = imageEntry.name.split('/').pop(); // Get filename without path
          
          // Create File object from blob
          const imageFile = new File([imageBlob], imageName, { type: imageBlob.type });
          
          // Create object URL for preview
          const imageUrl = URL.createObjectURL(imageBlob);
          
          // Create image object (use same path format as original uploads)
          const placeholder = `/Images/${imageName}`;
          const isCoverImage = coverImagePath && coverImagePath === placeholder;
          
          const imgObj = {
            file: imageFile,
            placeholder: isCoverImage ? placeholder : `![Image](${placeholder})`, // Cover images don't need markdown format
            url: imageUrl, // Add the URL for preview
            isCover: isCoverImage
          };
          
          window.attachedImages.push(imgObj);
          
          // Add to imageMap for preview rendering (match the original format)
          window.imageMap.set(placeholder, imageUrl);
          
          // Cache the loaded image
          cacheImage(imgObj);
          
          // If this is the cover image, show the preview
          if (isCoverImage) {
            const preview = document.getElementById('cover-preview');
            const container = document.getElementById('cover-preview-container');
            const info = document.getElementById('cover-info');
            
            preview.src = imageUrl;
            container.style.display = 'block';
            
            // Show file info
            const sizeKB = Math.round(imageFile.size / 1024);
            info.textContent = `File: ${imageName} (${sizeKB} KB) - Loaded from ZIP`;
          }
        }
        
        // Update image counter
        updateImageCounter();
        
        // Update preview
        updatePreview();
        
        // Show success message
        const imageCount = imageFiles.length;
        alert(`Project loaded successfully! 🎉\n\n📄 Loaded: ${markdownFile.name}\n${metadataFile ? '📋 Metadata: Restored\n' : ''}${imageCount > 0 ? `🖼️ Images: ${imageCount} file(s) loaded\n` : ''}📝 Ready to edit!`);
        
        // Show loaded state in upload area
        uploadContent.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="color: var(--c-accent);">
            <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" />
          </svg>
          <span style="color: var(--c-accent);">Project loaded: ${markdownFile.name.replace('.md', '')}</span>
          <small style="font-size: 12px; color: var(--c-dim); margin-top: 4px;">Upload another ZIP to replace</small>
        `;
        
        // Reset file input to allow reloading the same file
        document.getElementById('zipFileInput').value = '';
        
      } catch (error) {
        console.error('Error loading ZIP file:', error);
        alert(`Error loading ZIP file: ${error.message}\n\nPlease ensure you're uploading a valid Wave Finder blog post ZIP file.`);
        
        // Restore upload area
        const uploadContent = document.querySelector('.upload-content');
        uploadContent.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
          </svg>
          <span>Click to upload ZIP file or drag & drop</span>
        `;
      }
    }

    // ZIP file generation
    async function generateZipFile() {
      // Validate required fields
      const title = document.getElementById('title').value.trim();
      const author = document.getElementById('author').value.trim();
      const slug = document.getElementById('slug').value.trim();
      const excerpt = document.getElementById('excerpt').value.trim();
      
      if (!title || !author || !slug || !excerpt) {
        alert('Please fill in all required fields (Title, Author, Slug, Excerpt)');
        return;
      }

      // Validate slug format
      if (!/^[a-z0-9-]+$/.test(slug)) {
        alert('Slug must contain only lowercase letters, numbers, and hyphens');
        return;
      }

      if (!editor.value.trim()) {
        alert('Please write some content for your blog post');
        return;
      }

      // Show loading state
      const btn = event.target;
      const originalText = btn.innerHTML;
      btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="animation: spin 1s linear infinite;"><path d="M8 3a5 5 0 1 0 0 10 5 5 0 0 0 0-10zM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8z"/><path d="M8 4.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V5a.5.5 0 0 1 .5-.5z"/></svg> Generating...';
      btn.disabled = true;

      try {
        // Create ZIP file
        const zip = new JSZip();

        // Generate metadata JSON
        const metadata = {
          slug: slug,
          title: title,
          date: document.getElementById('date').value || new Date().toISOString().split('T')[0],
          author: author,
          tags: tags,
          excerpt: excerpt
        };

        const cover = document.getElementById('cover').value.trim();
        if (cover) {
          metadata.cover = cover;
        }

        // Add markdown file
        zip.file(`${slug}.md`, editor.value);

        // Add metadata JSON
        zip.file(`${slug}-metadata.json`, JSON.stringify(metadata, null, 2));

        // Add README with instructions
        const readme = `# Wave Finder Blog Post Submission

## Files Included:

1. **${slug}.md** - Your blog post content in markdown format
2. **${slug}-metadata.json** - Metadata to be added to blog_posts.json
${window.attachedImages && window.attachedImages.length > 0 ? `3. **Images/** - ${window.attachedImages.length} image file(s) referenced in your post\n` : ''}

## Submission Instructions:

1. Email this ZIP file to the Wave Finder team
2. The team will:
   - Add the metadata from \`${slug}-metadata.json\` to \`/data/blog_posts.json\`
   - Upload \`${slug}.md\` to \`/content/posts/\`
   - Upload any images to \`/Images/\`
3. Your blog post will then be live on Wave Finder!

## Image Paths Used:

${window.attachedImages && window.attachedImages.length > 0 
  ? window.attachedImages.map(img => `- ${img.placeholder} (from ${img.file.name})`).join('\n')
  : 'No images used in this post.'
}

## Contact:

Email this ZIP file to contribute your post to Wave Finder.

---
Generated by Wave Finder Blog Creator
Date: ${new Date().toISOString().split('T')[0]}
`;

        zip.file('README.txt', readme);

        // Add all attached images
        if (window.attachedImages && window.attachedImages.length > 0) {
          for (const img of window.attachedImages) {
            if (img.file) {
              zip.file(`Images/${img.file.name}`, img.file);
            }
          }
        }

        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const zipUrl = URL.createObjectURL(zipBlob);
        const zipLink = document.createElement('a');
        zipLink.href = zipUrl;
        zipLink.download = `${slug}-blog-post.zip`;
        zipLink.click();
        URL.revokeObjectURL(zipUrl);

        // Show success message
        const fileCount = 2 + (window.attachedImages ? window.attachedImages.length : 0) + 1; // md + json + images + readme
        alert(`Blog post package generated successfully! 📦\n\nZIP file contains:\n- ${slug}.md (blog content)\n- ${slug}-metadata.json (metadata)\n- README.txt (instructions)${window.attachedImages && window.attachedImages.length > 0 ? `\n- ${window.attachedImages.length} image file(s)` : ''}\n\nTotal: ${fileCount} files\n\nPlease email the ZIP file to contribute your post to Wave Finder!`);

      } catch (error) {
        console.error('Error generating ZIP:', error);
        alert('Error generating ZIP file. Please try again.');
      } finally {
        // Restore button
        btn.innerHTML = originalText;
        btn.disabled = false;
      }
    }

    function resetForm() {
      if (confirm('Are you sure you want to reset the form? All content will be lost.')) {
        document.getElementById('title').value = '';
        document.getElementById('author').value = '';
        document.getElementById('slug').value = '';
        document.getElementById('excerpt').value = '';
        document.getElementById('cover').value = '';
        document.getElementById('date').value = new Date().toISOString().split('T')[0];
        editor.value = '';
        tags = [];
        coverImageFile = null; // Clear cover image file
        window.attachedImages = []; // Clear attached images
        window.imageMap = new Map(); // Clear image preview map
        document.getElementById('cover-preview-container').style.display = 'none'; // Hide cover preview
        document.getElementById('cover-file-input').value = ''; // Reset file input
        renderTags();
        updatePreview();
      }
    }

    // Drag and drop for image upload
    const uploadArea = document.querySelector('.upload-area');
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      uploadArea.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
      uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
    });
    
    uploadArea.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        document.getElementById('image-file').files = files;
        handleImageUpload({ target: { files } });
      }
    });
    
    // Close dialog when clicking outside

    
    // Initialize
    editor.addEventListener('input', updatePreview);
    
    // Add cover image preview listener
    document.getElementById('cover').addEventListener('input', updateCoverPreview);
    editor.addEventListener('scroll', () => {
      // Sync scroll between editor and preview (optional)
      const scrollPercent = editor.scrollTop / (editor.scrollHeight - editor.clientHeight);
      const previewPanel = document.querySelector('.preview');
      previewPanel.scrollTop = scrollPercent * (previewPanel.scrollHeight - previewPanel.clientHeight);
    });

    // Keyboard shortcuts
    editor.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'b':
            e.preventDefault();
            wrapText('**');
            break;
          case 'i':
            e.preventDefault();
            wrapText('*');
            break;
          case 'k':
            e.preventDefault();
            insertLink();
            break;
        }
      }
    });

    // Initial preview update
    updatePreview();
    
    // Check for orphaned images after page refresh
    function checkForOrphanedImages() {
      // Wait a bit for the page to fully load
      setTimeout(() => {
        const content = editor.value;
        const coverImage = document.getElementById('cover').value;
        
        // Check for image references in markdown
        const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
        const images = [];
        let match;
        
        while ((match = imageRegex.exec(content)) !== null) {
          images.push({
            alt: match[1],
            src: match[2]
          });
        }
        
        // Check if we have image references but no imageMap
        const hasImageRefs = images.length > 0 || coverImage.trim();
        const hasImageMap = window.imageMap && window.imageMap.size > 0;
        
        if (hasImageRefs && !hasImageMap) {
          // Show notification about lost image previews
          showImageRestoreNotification(images, coverImage);
        }
      }, 100);
    }
    
    function showImageRestoreNotification(images, coverImage) {
      // Create backdrop overlay
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
        backdrop-filter: blur(4px);
      `;
      
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(255,193,7,0.9), rgba(255,152,0,0.9));
        color: #333;
        padding: 20px 24px;
        border-radius: 12px;
        box-shadow: 0 12px 32px rgba(0,0,0,0.4);
        z-index: 10000;
        max-width: 400px;
        min-width: 320px;
        font-family: inherit;
        font-size: 14px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
      `;
      
      const imageCount = images.length + (coverImage ? 1 : 0);
      
      notification.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 12px;">
          <div style="font-size: 20px;">⚠️</div>
          <div>
            <div style="font-weight: 600; margin-bottom: 8px;">Images Need Restoration</div>
            <div style="margin-bottom: 12px; line-height: 1.4;">
              Found ${imageCount} image reference(s) but previews were lost on page refresh.
            </div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button onclick="this.parentElement.parentElement.parentElement.parentElement.parentElement.remove()" style="
                background: rgba(0,0,0,0.1); 
                border: 1px solid rgba(0,0,0,0.2); 
                border-radius: 6px; 
                padding: 4px 8px; 
                font-size: 12px; 
                cursor: pointer;
                color: #333;
              ">Dismiss</button>
              <button onclick="restoreImagesOnly(); this.parentElement.parentElement.parentElement.parentElement.parentElement.remove();" style="
                background: rgba(0,0,0,0.15); 
                border: 1px solid rgba(0,0,0,0.3); 
                border-radius: 6px; 
                padding: 4px 8px; 
                font-size: 12px; 
                cursor: pointer;
                font-weight: 600;
                color: #333;
              ">Restore from ZIP</button>
            </div>
          </div>
        </div>
      `;
      
      // Add backdrop first, then notification on top
      document.body.appendChild(backdrop);
      backdrop.appendChild(notification);
      
      // Auto-hide after 15 seconds
      setTimeout(() => {
        if (backdrop.parentNode) {
          backdrop.style.transition = 'opacity 0.3s ease';
          backdrop.style.opacity = '0';
          setTimeout(() => {
            if (backdrop.parentNode) {
              backdrop.remove();
            }
          }, 300);
        }
      }, 15000);
    }
    
    function restoreImagesOnly() {
      // Create a separate file input for image restoration
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.zip';
      fileInput.style.display = 'none';
      
      fileInput.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
          await loadImagesFromZip(e.target.files[0]);
        }
        // Clean up the temporary input
        fileInput.remove();
      });
      
      document.body.appendChild(fileInput);
      fileInput.click();
    }
    
    async function loadImagesFromZip(file) {
      try {
        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(79, 195, 247, 0.9);
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          z-index: 10001;
          font-size: 14px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        loadingIndicator.innerHTML = '🔄 Restoring images...';
        document.body.appendChild(loadingIndicator);
        
        // Load and extract ZIP
        const zip = new JSZip();
        const zipContents = await zip.loadAsync(file);
        
        const imageFiles = [];
        let metadataFile = null;
        
        // Process each file in the ZIP
        for (const [filename, zipEntry] of Object.entries(zipContents.files)) {
          if (zipEntry.dir) continue; // Skip directories
          
          if (filename.endsWith('-metadata.json')) {
            metadataFile = zipEntry;
          } else if (filename.startsWith('Images/') && !filename.endsWith('/')) {
            imageFiles.push(zipEntry);
          }
        }
        
        // Get cover image path from metadata if available
        let coverImagePath = null;
        if (metadataFile) {
          const metadataContent = await metadataFile.async('text');
          const metadata = JSON.parse(metadataContent);
          coverImagePath = metadata.cover;
        }
        
        // Initialize image storage if not exists
        if (!window.attachedImages) window.attachedImages = [];
        if (!window.imageMap) window.imageMap = new Map();
        
        // Load images without clearing existing ones
        let addedCount = 0;
        for (const imageEntry of imageFiles) {
          const imageBlob = await imageEntry.async('blob');
          const imageName = imageEntry.name.split('/').pop(); // Get filename without path
          const placeholder = `/Images/${imageName}`;
          
          // Check if this image is already loaded
          const existingImage = window.attachedImages.find(img => 
            img.placeholder.includes(imageName) || img.placeholder === placeholder
          );
          
          if (!existingImage) {
            // Create File object from blob
            const imageFile = new File([imageBlob], imageName, { type: imageBlob.type });
            
            // Create object URL for preview
            const imageUrl = URL.createObjectURL(imageBlob);
            
            const isCoverImage = coverImagePath && coverImagePath === placeholder;
            
            const imgObj = {
              file: imageFile,
              placeholder: isCoverImage ? placeholder : `![Image](${placeholder})`,
              url: imageUrl,
              isCover: isCoverImage
            };
            
            window.attachedImages.push(imgObj);
            window.imageMap.set(placeholder, imageUrl);
            
            // Cache the restored image
            cacheImage(imgObj);
            addedCount++;
            
            // If this is the cover image, always update preview (whether field is empty or not)
            if (isCoverImage) {
              // Update the cover field if it's empty
              if (!document.getElementById('cover').value.trim()) {
                document.getElementById('cover').value = placeholder;
              }
              
              // Always show cover preview when restoring
              const preview = document.getElementById('cover-preview');
              const container = document.getElementById('cover-preview-container');
              const info = document.getElementById('cover-info');
              
              preview.src = imageUrl;
              container.style.display = 'block';
              
              const sizeKB = Math.round(imageFile.size / 1024);
              info.textContent = `File: ${imageName} (${sizeKB} KB) - Restored from ZIP`;
            }
          }
        }
        
        // Check if the current cover field value matches any restored image
        const currentCoverValue = document.getElementById('cover').value.trim();
        if (currentCoverValue && window.imageMap && window.imageMap.has(currentCoverValue)) {
          // Show cover preview for the matched image
          const preview = document.getElementById('cover-preview');
          const container = document.getElementById('cover-preview-container');
          const info = document.getElementById('cover-info');
          
          preview.src = window.imageMap.get(currentCoverValue);
          container.style.display = 'block';
          
          // Find the file info for display
          const matchedImage = window.attachedImages.find(img => 
            img.placeholder === currentCoverValue || img.placeholder.includes(currentCoverValue)
          );
          
          if (matchedImage) {
            const sizeKB = Math.round(matchedImage.file.size / 1024);
            info.textContent = `File: ${matchedImage.file.name} (${sizeKB} KB) - Restored from ZIP`;
          } else {
            info.textContent = 'Cover image restored from ZIP';
          }
        }
        
        // Update counters and preview
        updateImageCounter();
        updatePreview();
        
        // Remove loading indicator
        loadingIndicator.remove();
        
        // Show success message
        if (addedCount > 0) {
          const successIndicator = document.createElement('div');
          successIndicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 10001;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          `;
          successIndicator.innerHTML = `✅ Restored ${addedCount} image(s)`;
          document.body.appendChild(successIndicator);
          
          setTimeout(() => {
            successIndicator.style.transition = 'opacity 0.3s ease';
            successIndicator.style.opacity = '0';
            setTimeout(() => successIndicator.remove(), 300);
          }, 3000);
        } else {
          const noImagesIndicator = document.createElement('div');
          noImagesIndicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 10001;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          `;
          noImagesIndicator.innerHTML = 'ℹ️ All images already loaded';
          document.body.appendChild(noImagesIndicator);
          
          setTimeout(() => {
            noImagesIndicator.style.transition = 'opacity 0.3s ease';
            noImagesIndicator.style.opacity = '0';
            setTimeout(() => noImagesIndicator.remove(), 300);
          }, 3000);
        }
        
      } catch (error) {
        console.error('Error loading images from ZIP:', error);
        
        // Remove loading indicator if it exists
        const loadingIndicator = document.querySelector('div[style*="Restoring images"]');
        if (loadingIndicator) loadingIndicator.remove();
        
        // Show error message
        const errorIndicator = document.createElement('div');
        errorIndicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(244, 67, 54, 0.9);
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          z-index: 10001;
          font-size: 14px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 300px;
        `;
        errorIndicator.innerHTML = `❌ Error restoring images: ${error.message}`;
        document.body.appendChild(errorIndicator);
        
        setTimeout(() => {
          errorIndicator.style.transition = 'opacity 0.3s ease';
          errorIndicator.style.opacity = '0';
          setTimeout(() => errorIndicator.remove(), 300);
        }, 5000);
      }
    }

    // Image caching system
    let imageDB;
    
    async function initializeImageCache() {
      try {
        // Initialize IndexedDB for image storage
        imageDB = await new Promise((resolve, reject) => {
          const request = indexedDB.open('WaveFinderBlogImages', 1);
          
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('images')) {
              db.createObjectStore('images', { keyPath: 'id' });
            }
          };
        });
        
        // Restore cached images
        await restoreCachedImages();
      } catch (error) {
        console.error('Error initializing image cache:', error);
      }
    }
    
    async function cacheImage(imageObj) {
      try {
        if (!imageDB) return;
        
        // Store image in IndexedDB
        const transaction = imageDB.transaction(['images'], 'readwrite');
        const store = transaction.objectStore('images');
        
        // Convert file to array buffer for storage
        const arrayBuffer = await imageObj.file.arrayBuffer();
        
        const cacheData = {
          id: imageObj.placeholder,
          arrayBuffer: arrayBuffer,
          fileName: imageObj.file.name,
          fileType: imageObj.file.type,
          fileSize: imageObj.file.size,
          isCover: imageObj.isCover || false,
          timestamp: Date.now()
        };
        
        await store.put(cacheData);
        
        // Update localStorage with image metadata
        const cachedImages = JSON.parse(localStorage.getItem('wf-cached-images') || '[]');
        const existingIndex = cachedImages.findIndex(img => img.id === imageObj.placeholder);
        
        if (existingIndex >= 0) {
          cachedImages[existingIndex] = {
            id: imageObj.placeholder,
            fileName: imageObj.file.name,
            isCover: imageObj.isCover || false,
            timestamp: Date.now()
          };
        } else {
          cachedImages.push({
            id: imageObj.placeholder,
            fileName: imageObj.file.name,
            isCover: imageObj.isCover || false,
            timestamp: Date.now()
          });
        }
        
        localStorage.setItem('wf-cached-images', JSON.stringify(cachedImages));
        
      } catch (error) {
        console.error('Error caching image:', error);
      }
    }
    
    async function restoreCachedImages() {
      try {
        if (!imageDB) return;
        
        const cachedImagesList = JSON.parse(localStorage.getItem('wf-cached-images') || '[]');
        if (cachedImagesList.length === 0) return;
        
        // Initialize storage if needed
        if (!window.attachedImages) window.attachedImages = [];
        if (!window.imageMap) window.imageMap = new Map();
        
        const transaction = imageDB.transaction(['images'], 'readonly');
        const store = transaction.objectStore('images');
        
        let restoredCount = 0;
        
        for (const cachedInfo of cachedImagesList) {
          try {
            // Check if image is already loaded
            const existing = window.attachedImages.find(img => img.placeholder === cachedInfo.id);
            if (existing) continue;
            
            const request = store.get(cachedInfo.id);
            const result = await new Promise((resolve, reject) => {
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });
            
            if (result) {
              // Recreate File object from stored data
              const fileBlob = new Blob([result.arrayBuffer], { type: result.fileType });
              const imageFile = new File([fileBlob], result.fileName, { type: result.fileType });
              
              // Create object URL for preview
              const imageUrl = URL.createObjectURL(fileBlob);
              
              const imgObj = {
                file: imageFile,
                placeholder: result.isCover ? result.id : `![Image](${result.id})`,
                url: imageUrl,
                isCover: result.isCover
              };
              
              window.attachedImages.push(imgObj);
              window.imageMap.set(result.id, imageUrl);
              
              // Handle cover image
              if (result.isCover) {
                const currentCover = document.getElementById('cover').value.trim();
                if (!currentCover || currentCover === result.id) {
                  document.getElementById('cover').value = result.id;
                  
                  // Show cover preview
                  const preview = document.getElementById('cover-preview');
                  const container = document.getElementById('cover-preview-container');
                  const info = document.getElementById('cover-info');
                  
                  preview.src = imageUrl;
                  container.style.display = 'block';
                  
                  const sizeKB = Math.round(result.fileSize / 1024);
                  info.textContent = `File: ${result.fileName} (${sizeKB} KB) - Cached`;
                }
              }
              
              restoredCount++;
            }
          } catch (error) {
            console.error('Error restoring cached image:', cachedInfo.id, error);
          }
        }
        
        if (restoredCount > 0) {
          // Update UI
          updateImageCounter();
          updatePreview();
          
          // Show brief notification
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            z-index: 10001;
            font-size: 13px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          `;
          notification.innerHTML = `💾 Restored ${restoredCount} cached image(s)`;
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.transition = 'opacity 0.3s ease';
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
          }, 2000);
        }
        
      } catch (error) {
        console.error('Error restoring cached images:', error);
      }
    }
    
    async function clearImageCache() {
      try {
        if (imageDB) {
          const transaction = imageDB.transaction(['images'], 'readwrite');
          const store = transaction.objectStore('images');
          await store.clear();
        }
        localStorage.removeItem('wf-cached-images');
      } catch (error) {
        console.error('Error clearing image cache:', error);
      }
    }

    // Initialize ZIP upload functionality
    setupZipUpload();
    
    // Initialize image caching
    initializeImageCache();
    
    // Check for orphaned images on page load (fallback)
    checkForOrphanedImages();
  </script>
</body>
</html>